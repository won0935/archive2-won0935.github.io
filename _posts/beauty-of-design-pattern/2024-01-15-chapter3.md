---
title: "[3장] 설계원칙"
date: '2024-01-15'
categories: [ 설계, 디자인 패턴의 아름다움 `]
tags: [ 면접, 다자인패턴, 설계 ]
---


# SOLID

## SRP (Single Responsibility Principle)
- 하나의 클래스나 모듈은 하나의 책임만 가져야 한다.
- 클래스와 모듈은 서로 의미가 동일하다.

### 클래스를 분리해야하는 기준
- 클래스에 코드, 함수 또는 속성이 너무 많아 코드의 가독성과 유지 보수성에 영향을 미치는 경우
- 클래스가 너무 과하게 다른 클래스에 의존하는 경우
- 클래스에 `private` 메소드가 너무 많은 경우
- 클래스의 이름을 명확하게 지정하기 어려운 경우(`Manager`, `Context`.. 뜨끔😅) 
- 클래스의 많은 메소드나 항목이 일부 로직에서만 작동하는 경우

### 생각해보기
- 클래스 외에 단일 책임 원칙을 적용할 수 있는 설계에는 어떤 것들이 있을까


## OCP (Open Closed Principle)
- 확장에는 열려있고, 변경에는 닫혀있어야 한다.
- 가장 어렵지만 유용한 원칙
> 이해하기 어려운 이유
> - 코드를 변경할 때 확장으로 보아야 하는지 수정으로 보아야 하는지 판단하기 어렵기 떄문

> 유용한 이유
> - 객체지향에서는 **확장성이 코드 품질의 중요한 척도**이기 때문
> - 디자인 패턴의 대부분은 **확장성 문제**를 해결하기 위함임

### 코드를 수정하는 것은 개방 폐쇠 원칙을 위반하는 것일까?
- 결론만 말하자면 기존 코드를 전혀 수정하지 않는 것은 불가능함
- **단위테스트를 깨트리지 않는 한** 코드를 수정하는 것은 개방 폐쇠 원칙를 위반하는 것이 아님

### 개방 폐쇠 원칙을 달성하는 방법
- 코드를 작성할 때 앞으로 요구사항이 추가될 가능성이 있는지 고려해야 함(다형성)
- 코드의 변경가능한 부분과 변경할 수 없는 부분을 잘 식별해야 함(캡슐화)
- 코드의 **확장성**은 코드 품질을 판단하는 중요한 기준임

### 실무에 적용하기
- 아래와 같은 경우 확장 포인트를 미리 준비 
  - 단기간에 진행할 수 있는 확장
  - 코드 구조 변경에 미치는 영향이 큰 확장 
  - 비용이 많이 들지않는 확장
- 아래와 같은 경우 필요할 때 리펙토링
  - 후에 지원해야 하는 여부가 확실하지 않은 경우
  - 확장이 코드개발에 부하를 주는 경우

### 생각해보기
- 개방 폐쇠 원칙이 생겨난 이유가 무엇일까


## LSP (Liskov Substitution Principle)
- 자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.

### 리스코프 치환 원칙과 다형성의 차이점
- 보기에는 비슷하나 완전히 다른 의미임
- 리스코프 치환 원칙은 상위 클래스를 대체할 때 프로그램의 **원래 논리적 동작이 변경되지 않고 프로그램의 정확성이 손상되지 않도록 해야한다**는 의미임(비즈니스 로직의 통일성이 중요)

### 리스코프 치환 원칙을 위반하는 경우
- 계약에 따른 설계
  - 하위 클래스를 설계할 때는 상위 클래스의 **동작 규칙**을 따라야함
  - 하위 클래스는 내부 구현 논리를 변경할 수 있지만 **동작 규칙**은 변경할 수 없음
  - **동작 규칙**에 포함되는 것들
    - 함수의 입출력
    - 예외에 대한 규칙
    - 주석에 나열된 특수 지침

#### 하위 클래스가 구현하려는 상위 클래스에서 선언한 기능을 위반하는 경우
- ex> 메소드를 오버라이드해서 완전히 다른 기능을 구현한 경우
#### 하위 클래스가 입력, 출력 및 예외에 대한 상위클래스의 계약을 위반하는 경우
- ex> 상위 클래스의 메소드가 장애 시 `CustomException`을 발생시킨다는 계약을 가지고 있지만 하위 클래스에서는 다른 예외를 발생하는 경우
#### 하위 클래스가 상위 클래스의 주석에 나열된 특별 지침을 위반하는 경우
- ex> 상위 클래스에서 선언한 비즈니스로직을 하위 클래스에서 재정의하는 경우
- 이 경우 상위 클래스의 주석을 수정하는 편이 나음

### 리스코프 치환 원칙을 확인하는 꿀팁
- 상위 클래스의 단위 테스트로 하위 클래스의 코드를 확인

### 생각해보기
- 리스코프 치환 원칙이 중요한 이유


## ISP (Interface Segregation Principle)



## DIP (Dependency Inversion Principle)
